#include <pty.h>
#include <time.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <signal.h>
#include <termios.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/epoll.h>
#include <sys/types.h>

#include "cmdline.h"
#include "utils.h"


#define CAPTURE_DIR_MAX 256
#define MAX_EVENTS 4


static int global_master_fd = -1;


/* -------------------------------------------
   SYNC PTY WINDOW SIZE WITH REAL TERMINAL
-------------------------------------------- */
void update_winsize() {
    if (global_master_fd < 0) return;

    struct winsize ws;
    if (ioctl(STDIN_FILENO, TIOCGWINSZ, &ws) == 0) {
        ioctl(global_master_fd, TIOCSWINSZ, &ws);
    }
}

void handle_winch(int sig) {
    update_winsize();
}



int main(int argc, char ** argv) {
    /* ------------------------------------------------------------------
       TODO: consider dynamic allocation for improved flexibility.
    ------------------------------------------------------------------- */
    char capture_dir[CAPTURE_DIR_MAX];
    char path_shell_capture[300];
    char capture_name[30] = "capture";
    
    /* ------------------------------------------------------------------
       Parse command-line options generated by gengetopt.
       Aborts on invalid arguments.
    ------------------------------------------------------------------- */
    struct gengetopt_args_info tool_input;
    if (cmdline_parser(argc, argv, &tool_input) != 0) {
        perror("[ERROR] Failed to parse input");
        exit(1);
    }

    /* Enable verbose logging if requested */
    setVerbose(tool_input.verbose_flag);
    verbose("Verbose flag activated");
    verbose("Network flag: %d\n", tool_input.network_flag);
    verbose("Output string: %s\n", tool_input.output_arg);

    /* Use custom capture name if provided */
    if (tool_input.capture_arg) {
        snprintf(capture_name, sizeof(capture_name), "%s", tool_input.capture_arg);
    }
    verbose("Capture name: %s\n", capture_name);

    /* ------------------------------------------------------------------
       Determine output directory:
         - If user supplied --output, use it.
         - Otherwise generate /tmp/<name>_<timestamp>.
    ------------------------------------------------------------------- */
    if (!tool_input.output_given){
        time_t rawtime;
        struct tm * timeinfo;
        char timestamp[64];

        time(&rawtime);
        timeinfo = localtime(&rawtime);
        strftime(timestamp, sizeof(timestamp), "%Y_%m_%d_%H_%M_%S", timeinfo);
        snprintf(capture_dir, sizeof(capture_dir),"/tmp/%s_%s", capture_name, timestamp);
    } else{
        snprintf(capture_dir, sizeof(capture_dir), "%s", tool_input.output_arg);
    }
    verbose("Output string: %s\n", capture_dir);

    /* Create the main capture directory */
    int result = mkdir(capture_dir, 0755);
    if (result == -1){
        perror("[ERROR] Failed to create the directory\n");
        exit(1);
    }
    verbose("Log are saved in path: %s\n", capture_dir);
    
    /* Open log file used to capture PTY output */
    snprintf(path_shell_capture, sizeof(path_shell_capture), "%s/collector_output.log", capture_dir);
    FILE *capture = fopen(path_shell_capture, "a");
    if (!capture) {
        perror("[ERROR] Cannot open capture log");
        exit(1);
    }
    verbose("Shell output is saved in path: %s\n", path_shell_capture);

    /* ------------------------------------------------------------------
       Spawn a real interactive shell inside a fresh PTY.
       Parent receives master_fd and controls I/O forwarding.
    ------------------------------------------------------------------- */
    int master_fd;
    pid_t pid;
    /* ------------------------------------------------------------------
    TODO: improve function without giving the responsability of the free 
    ------------------------------------------------------------------- */
    char *shell_path = get_parent_shell_path();
    verbose("Shell path = %s\n", shell_path);
    
    pid = forkpty(&master_fd, NULL, NULL, NULL);
    if (pid < 0) {
        perror("[ERROR] forkpty failed");
        exit(1);
    }

    /* Child replaces itself with the invoked shell */
    if (pid == 0) {
        execl(shell_path, shell_path, "-i", NULL);
        perror("[ERROR] execl failed");
        free(shell_path);
        exit(1);
    }

    free(shell_path);

    /* ---------------- PARENT ---------------- */
    /* ------------------------------------------------------------------
    TODO: Avoid the use of global_master_fd
    ------------------------------------------------------------------- */
    global_master_fd = master_fd;

    /* Sync window size immediately */
    update_winsize();

    /* Install SIGWINCH handler */
    signal(SIGWINCH, handle_winch);

    // Switch our own stdin to raw mode so keystrokes are forwarded exactly.
    struct termios orig, raw;
    tcgetattr(STDIN_FILENO, &orig);
    raw = orig;
    cfmakeraw(&raw);
    tcsetattr(STDIN_FILENO, TCSANOW, &raw);

    int ep = epoll_create1(0);
    if (ep == -1) {
        perror("[ERROR] epoll_create1 failed\n");
        tcsetattr(STDIN_FILENO, TCSANOW, &orig);
        exit(1);
    }

    // Register stdin with epoll
    struct epoll_event ev_stdin = {0};
    ev_stdin.events = EPOLLIN;
    ev_stdin.data.fd = STDIN_FILENO;
    epoll_ctl(ep, EPOLL_CTL_ADD, STDIN_FILENO, &ev_stdin);

    // Register PTY master fd with epoll
    struct epoll_event ev_pty = {0};
    ev_pty.events = EPOLLIN;
    ev_pty.data.fd = master_fd;
    epoll_ctl(ep, EPOLL_CTL_ADD, master_fd, &ev_pty);
    
    // \n to flush because you are in raw
    printf("[Interactive PTY shell started. Ctrl+C, arrow keys, etc. fully work]\n");

    struct epoll_event events[MAX_EVENTS];
    char buf[4096];
    int running = 1;

    while (running) {

        // Wait for input events (keyboard or PTY output)
        int n_events = epoll_wait(ep, events, MAX_EVENTS, -1);
        if (n_events < 0) {
            perror("[ERROR] epoll_wait failed");
            break;
        }

        for (int i = 0; i < n_events; i++) {
            int fd = events[i].data.fd;
            uint32_t ev = events[i].events;

            // Shell closed or PTY hangup
            if (ev & (EPOLLHUP | EPOLLERR)) {
                running = 0;
                break;
            }

            // Keyboard → PTY
            if (fd == STDIN_FILENO && (ev & EPOLLIN)) {
                ssize_t n = read(STDIN_FILENO, buf, sizeof(buf));
                if (n <= 0) { 
                    running = 0; 
                    break; 
                }
                write(master_fd, buf, n);
            }
 
            // PTY → screen AND log collector
            else if (fd == master_fd && (ev & EPOLLIN)) {
                ssize_t n = read(master_fd, buf, sizeof(buf));
                if (n <= 0) { 
                    running = 0; 
                    break; 
                }
            
                // Write to terminal
                write(STDOUT_FILENO, buf, n);
            
                // Write to capture file
                fwrite(buf, 1, n, capture);
                fflush(capture);  // ensure durability
            }
        }
    }

    // Restore terminal settings
    tcsetattr(STDIN_FILENO, TCSANOW, &orig);

    // Cleanup
    close(ep);
    waitpid(pid, NULL, 0);

    return 0;
}
