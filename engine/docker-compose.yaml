services:
  redis:
    image: redis:latest
    container_name: redis
    command: ["redis-server", "--appendonly", "yes"]
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
      timeout: 3s
      retries: 20
    networks:
      - backend

  graphdb:
    image: ontotext/graphdb:10.8.11
    container_name: graphdb
    ports:
      - "7200:7200"
    volumes:
      - graphdb_data:/opt/graphdb/home
    environment:
      - JAVA_OPTS=-Xms1g -Xmx2g
    restart: unless-stopped
    networks:
      - backend

  graphdb-init:
    image: curlimages/curl:latest
    container_name: graphdb-init
    depends_on:
      - graphdb
    volumes:
      - ./graphdb:/graphdb:ro
    entrypoint:
      - sh
      - -c
      - |
        set -e

        GDB_URL="http://graphdb:7200"
        REPO_ID="ontowebpt"
        REPO_CONFIG="/graphdb/repository.ttl"
        ONTOLOGY_FILE="/graphdb/ontology.rdf"

        echo ">>> Waiting for GraphDB (checking $$GDB_URL/rest/repositories)..."

        # Wait until GraphDB responds on /rest/repositories with HTTP 200
        while :; do
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$$GDB_URL/rest/repositories" || echo "000")
          echo "Current HTTP code from $$GDB_URL/rest/repositories: $$HTTP_CODE"

          if [ "$$HTTP_CODE" = "200" ]; then
            break
          fi

          echo "GraphDB not ready yet, retrying in 3s..."
          sleep 3
        done

        echo ">>> GraphDB is up."

        echo ">>> Checking if repository '$$REPO_ID' exists in /rest/repositories ..."

        REPO_LIST=$(curl -s "$$GDB_URL/rest/repositories" || echo "")
        echo "Current repositories response:"
        echo "$$REPO_LIST"

        if echo "$$REPO_LIST" | grep -q "\"id\" *: *\"$$REPO_ID\""; then
          echo ">>> Repository '$$REPO_ID' already exists."
        else
          echo ">>> Repository '$$REPO_ID' does not exist. Creating..."

          curl -v -X POST "$$GDB_URL/rest/repositories" \
            -H "Accept: application/json" \
            -H "Content-Type: multipart/form-data" \
            -F "config=@$$REPO_CONFIG"

          echo ">>> Repository created."
        fi

        echo ">>> Checking if ontology is already present in repository '$$REPO_ID'..."

        ASK_RESPONSE=$(curl -s -G "$$GDB_URL/repositories/$$REPO_ID" \
          --data-urlencode 'query=PREFIX owl: <http://www.w3.org/2002/07/owl#> ASK WHERE { ?s a owl:Ontology . }' \
          -H "Accept: application/sparql-results+json" || echo "")

        echo "ASK response:"
        echo "$$ASK_RESPONSE"

        if echo "$$ASK_RESPONSE" | grep -q '"boolean" *: *true'; then
          echo ">>> Ontology is already present. Skipping import."
          exit 0
        fi

        echo ">>> Ontology not found. Importing from '$$ONTOLOGY_FILE'..."

        curl -v -X POST \
          -H "Content-Type: application/rdf+xml" \
          --data-binary "@$$ONTOLOGY_FILE" \
          "$$GDB_URL/repositories/$$REPO_ID/statements"

        echo ">>> Ontology import completed."
    networks:
      - backend
    restart: "no"
    
  #node-api:
  #  build:
  #    context: ./nodejs
  #    dockerfile: Dockerfile
  #  container_name: node-api
  #  command: ["npm", "run", "start:api"]
  #  ports:
  #    - "8081:8081"
  #  env_file:
  #    - ./nodejs/.env
  #  environment:
  #    SERVER_HOST: "0.0.0.0"
  #    GRAPHDB_BASE: "http://graphdb:7200"
  #    REDIS_HOST: "redis"
  #
  #    TSHARK_BIN: "/usr/bin/tshark"
  #  depends_on:
  #    - redis
  #    - graphdb
  #  networks:
  #    - backend

  #node-worker:
  #  build:
  #    context: ./nodejs
  #    dockerfile: Dockerfile
  #  container_name: node-worker
  #  command: ["npm", "run", "start:worker"]
  #  env_file:
  #    - ./nodejs/.env
  #  environment:
  #    GRAPHDB_BASE: "http://graphdb:7200"
  #    REDIS_HOST: "redis"
  #    TSHARK_BIN: "/usr/bin/tshark"
  #  depends_on:
  #    - redis
  #    - graphdb
  #  networks:
  #    - backend

  nginx:
    image: nginx:alpine
    container_name: nginx
    depends_on: []
    extra_hosts:
      - "host.docker.internal:host-gateway"
    ports:
      - "80:80"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "wget -qO- http://localhost/health || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 12
    networks:
      - frontend

volumes:
  redis_data:
  graphdb_data:

networks:
  frontend:
    driver: bridge
  backend:
    driver: bridge
