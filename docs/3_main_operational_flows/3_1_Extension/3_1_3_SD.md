# Sequence Diagrams
---

- [Global](./3_1_3_SD/3_1_3_1_Global.md)
- [Techstack](./3_1_3_SD/3_1_3_2_Techstack.md)
- [Analyzer](./3_1_3_SD/3_1_3_3_Analyzer.md)
- [Interceptor](./3_1_3_SD/3_1_3_4_Interceptor.md)

---

Il documento “Sequence Diagrams” della sezione Extension raccoglie, in forma grafica (diagrammi di sequenza), i principali flussi dinamici dell’estensione lato popup.  
Mentre i *Functional Requirements* descrivono “che cosa” il sistema deve fare e i *Use Cases* raccontano “come” l’utente interagisce, i sequence diagrams mostrano “chi parla con chi e in quale ordine” (UI, controller, servizi di storage, background scripts, backend Tool, ecc.) durante i vari scenari.

---

Ogni gruppo di diagrammi è descritto in un file dedicato, allineato alle quattro aree funzionali già viste nelle altre sezioni:

1. Global  
   La sezione Global dei sequence diagrams rappresenta i comportamenti trasversali comuni a tutta l’estensione. In particolare, i diagrammi mostrano:
   - cosa succede quando l’utente apre la popup su una scheda (scelta tra Home, ultima route salvata, o vista runtime se c’è una sessione “live” attiva);
   - come avviene la navigazione tra le sezioni principali (Home, Technology Stack, Analyzer, Interceptor) e tra le sotto-pagine interne, con salvataggio del contesto nello storage per tab;
   - come funziona il lock globale di scansione: richiesta di lock da parte di un modulo, concessione o rifiuto, avvio/rilascio a fine scansione, gestione del conflitto quando un altro modulo è già in esecuzione;
   - come si propaga il cambio tema chiaro/scuro, con tentativo di persistenza in storage e gestione dei possibili errori di salvataggio;
   - come il servizio di stato del Tool effettua periodicamente l’health-check verso il backend e aggiorna l’indicatore globale (Checking/Tool On/Tool Off);
   - il modello di notifica globale non bloccante (toast/snackbar) utilizzato da tutte le sezioni per segnalare successi, warning ed errori senza interrompere l’interazione con l’utente.

2. Techstack  
   La sezione Techstack dei sequence diagrams si concentra sui flussi legati alla scansione dello stack tecnologico della pagina, alla gestione dei risultati e al workflow di analisi. I diagrammi illustrano:
   - il flusso di “Scan current tab”: inizializzazione della vista, caricamento dell’ultimo risultato disponibile, richiesta/acquisizione del lock globale, invocazione del componente di scansione, salvataggio dei risultati e aggiornamento della UI; con gestione dei casi di lock occupato o errori di scansione;
   - la logica di caricamento automatico dell’ultimo risultato Techstack, con priorità per contesto (prima scheda corrente, poi sessione globale, poi archivio locale) e visualizzazione della provenienza del dato;
   - le interazioni nella vista Archive: caricamento dell’archivio suddiviso per contesti, espansione e visualizzazione dei singoli snapshot con la stessa struttura della vista Scan, export JSON, delete singolo e delete all con ricarica e notifiche;
   - il wizard “Analyze”: verifica preliminare di Tool On e lock globale, caricamento delle scansioni disponibili da locale, selezione dello snapshot, anteprima, invio al backend, creazione dei job, e monitoraggio tramite un componente di Job Monitor che aggiorna il dialog “Job Summaries” finché tutti i job non sono completati o falliti.

3. Analyzer  
   La sezione Analyzer dei sequence diagrams descrive i flussi dinamici più articolati legati all’analisi del DOM e dei contenuti HTML, sia in modalità one-shot sia runtime, inclusi archivio e Analyze. I diagrammi coprono:
   - la One-Time Scan: ingresso nella vista, caricamento automatico dell’ultimo risultato per contesto, richiesta del lock globale, invocazione del componente di scansione, salvataggio nei vari livelli (per tab, per sessione, locale) e aggiornamento della UI; gestione di errori e lock occupato;
   - la Runtime Scan: avvio della sessione (acquisizione del lock, creazione della sessione runtime, avvio dello scanner continuo), aggiornamento dei contatori live (pagine, snapshot, stato RUNNING/STOPPED) e stop della sessione (chiusura scanner, salvataggio dati, rilascio lock, caricamento del run appena concluso);
   - l’archivio Analyzer: caricamento e organizzazione degli snapshot One-Time per contesto, lista delle sessioni Runtime, espansione di gruppi/run, eventuale caricamento lazy dei dettagli, cancellazioni singole o massive, refresh e notifiche di esito;
   - il wizard “Analyze” per One-Time e Runtime: verifica di Tool On e lock, caricamento delle liste di snapshot/run, selezione progressiva (per il runtime: run → pagina → snapshot), anteprima dello snapshot scelto, invio al backend, creazione dei job e monitoraggio tramite dialog “Job Summaries”, con reset del wizard alla chiusura.

4. Interceptor  
   La sezione Interceptor dei sequence diagrams rappresenta i flussi relativi alla cattura runtime del traffico HTTP/HTTPS e al percorso guidato di invio richieste verso l’ontologia (GraphDB) e il resolver. I diagrammi mostrano:
   - il ciclo di vita della Runtime Interceptor: apertura della vista Runtime Scan, verifica dello stato sessione, avvio della cattura con acquisizione del lock globale, aggiornamento continuo dei contatori (pagine, eventi, bytes), salvataggio degli eventi e arresto della sessione con rilascio del lock e aggiornamento del pannello di stato;
   - il caricamento automatico dell’ultimo run runtime (se non c’è una sessione live) e la consultazione dei risultati: recupero dei metadati, vista raggruppata per pagina/dominio, caricamento degli eventi della pagina, tabella richieste e dialog di dettaglio con JSON di request/response/meta;
   - la gestione dell’archivio Runtime Interceptor: caricamento dell’elenco sessioni, aggiornamento automatico alla fine di nuove sessioni o manuale via refresh, caricamento lazy dei dati di un run specifico, cancellazione singola o “Delete All” con ricarica e notifiche;
   - il wizard “Send to ontology”: verifica preliminare di Tool On e lock, selezione della scansione (Choose a scan), selezione del website/pagina (Choose a website), selezione e ispezione delle richieste (Select requests), riepilogo finale con eventuale attivazione del resolver (Confirm and send), invio dei batch verso il backend e apertura del dialog “Job Summaries”;
   - il monitoraggio dei job di ingestione/risoluzione: popolamento e aggiornamento in tempo reale dello stato dei job nel dialog, sospensione del polling al completamento/fallimento di tutti i job, chiusura del dialog e reset del wizard pronto per un nuovo invio.

---
