# Casi d’uso – Dashboard
---

- [Global](./3_2_2_UC/3_2_2_1_Global.md)
- [Http Requests](./3_2_2_UC/3_2_2_2_Http_Requests.md)
- [Findings](./3_2_2_UC/3_2_2_3_Findings.md)
- [Send PCAP](./3_2_2_UC/3_2_2_4_Send_PCAP.md)
- [Tool Status](./3_2_2_UC/3_2_2_5_Tool_Status.md)
- [OpenAPI](./3_2_2_UC/3_2_2_6_OpenAPI.md)

---

Il documento “Use Cases” della sezione **Dashboard** descrive, dal punto di vista dell’utente, gli scenari operativi principali coperti dall’interfaccia web di OntoWeb-PT.  
Per ogni area funzionale vengono illustrati:
- gli attori coinvolti (tipicamente il penetration tester o analista di sicurezza);
- l’obiettivo dello scenario (cosa vuole ottenere l’utente);
- le precondizioni minime;
- il flusso di interazione passo-per-passo;
- le possibili varianti/estensioni e i comportamenti in caso di errore.

---

Il documento è organizzato in **sei** gruppi di casi d’uso, ciascuno approfondito in un file dedicato.

---

1. **Global**  
    Racchiude i casi d’uso trasversali a tutte le pagine della dashboard, indipendenti dallo specifico dominio funzionale (Requests, Findings, ecc.). In particolare descrive come l’utente:
    - naviga tra le sezioni principali (Home, HTTP Requests, Findings, Send PCAP, Tool Status, OpenAPI) tramite nav laterale e logo;
    - utilizza URL leggibili e stabili (routing) per atterrare direttamente su viste specifiche, mantenendo coerenza tra URL, history del browser e contenuto visualizzato;
    - usa la sotto-navigazione contestuale di Findings (HTTP / Analyzer / Techstack) quando si trova all’interno del path `/findings`;
    - cambia tema chiaro/scuro tramite il controllo globale in AppBar, vede il cambio applicato all’intera dashboard e la preferenza ricordata tra una sessione e l’altra;
    - consulta lo stato sintetico del Tool (chip “Tool Checking / Tool On / Tool Off” nella barra superiore) e ne interpreta il significato rispetto alla disponibilità del backend;
    - atterra sulla Home come pagina di onboarding, legge una breve introduzione a OntoWeb-PT e utilizza le feature card per accedere rapidamente alle sezioni principali;
    - beneficia di un layout responsivo e coerente (AppBar + nav laterale + area contenuti) che si adatta a desktop e schermi ridotti, mantenendo sempre chiari i punti di accesso alle funzioni;
    - riceve feedback non bloccanti tramite snackbar globali (esito di caricamenti, errori di rete, applicazione filtri, ecc.), continuando a lavorare senza interruzioni;
    - continua a utilizzare la dashboard anche in presenza di problemi con lo storage locale o con servizi globali (health), grazie a un comportamento di degrado controllato (tema di default, stato tool “off”, ma UI comunque utilizzabile).

---

2. **Http Requests**  
    Copre i casi d’uso relativi alla sezione **HTTP Requests**, che permette di esplorare le richieste HTTP già ingerite e normalizzate nell’ontologia.
    
    I casi d’uso descrivono come l’utente:
    - visualizza la lista paginata di richieste HTTP provenienti da GraphDB (server-side pagination con offset/limit), scegliendo il numero di elementi per pagina e scorrendo tra le pagine mantenendo i filtri attivi;
    - percepisce la differenza tra primo caricamento (Backdrop bloccante per evitare una tabella “vuota”) e caricamenti successivi (spinner integrato nella DataGrid, tabella sempre visibile);
    - restringe i risultati tramite la toolbar di filtri (method, scheme, authority, path, full-text), con normalizzazione degli input e invio al backend solo dei campi realmente valorizzati;
    - applica o resetta i filtri usando i pulsanti **Apply** e **Reset**, con change-detection per evitare chiamate ridondanti, reset della paginazione alla prima pagina e snackbar di conferma dell’avvenuta applicazione;
    - gestisce gli errori di caricamento della lista con messaggi chiari e non bloccanti, mantenendo comunque l’ultimo set valido di risultati, oppure vedendo un messaggio esplicito in assenza di dati (“No requests to show.”);
    - apre il dettaglio di una singola richiesta tramite icona “View details”, visualizzando un drawer laterale con: header riassuntivo (method, status colorato, URL, graph, authority), sezione **Request** (URI, query params, headers) e sezione **Response** (status, headers, body, azione “Copy body”);
    - interpreta al volo lo stato delle richieste grazie alla codifica colore dei codici HTTP (2xx/3xx/4xx/5xx) sia in lista sia nel dettaglio;
    - sperimenta un comportamento coerente tra filtri, paginazione e chiamate al backend, con sincronizzazione costante tra gli stati interni (filtri, page/pageSize) e i parametri effettivamente utilizzati nelle query.

---

3. **Findings**  
    Raccoglie i casi d’uso relativi alla sezione **Findings**, che organizza e rende consultabili le evidenze generate dall’analisi del traffico HTTP, di Analyzer e di Techstack.
    
    Vengono descritti scenari in cui l’utente:
    - entra in `/findings` e viene portato di default sugli **HTTP Findings**, con sotto-navigazione in AppBar che consente il passaggio rapido a **Analyzer Findings** e **Techstack Findings**;
    - utilizza la sotto-navigazione interna (tab HTTP / Analyzer / Techstack) per spostarsi tra i tre tipi di findings, vedendo sempre evidenziata la vista attiva;
    - interagisce con tre pagine che condividono layout e comportamento: titolo, descrizione introduttiva animata (Zoom), DataGrid con paginazione server-side e messaggio esplicito in assenza di dati;
    - osserva la paginazione server-side delle liste di findings (offset/limit, total, hasNext/hasPrev) e cambia pagina/page size, con sincronizzazione costante dello stato di paginazione per ciascun tipo di finding;
    - sperimenta la gestione unificata degli stati di caricamento: Backdrop bloccante al primo load, spinner della DataGrid per i caricamenti successivi;
    - riceve messaggi chiari in caso di errore di caricamento di una delle tre liste (HTTP / Analyzer / Techstack), senza crash né blocchi (semplicemente la griglia resta vuota e compare “No findings to show.”).
    
    Per i dettagli specifici:
    
    - **HTTP Findings**
        - consulta una tabella che espone colonne sintetiche come Finding ID, Rule e Target (derivate dall’ID del finding), più una colonna Actions con icona “View details”;
        - apre il drawer di dettaglio e vede header con regola (ruleId), severità (chip colorato), descrizione, metadati (Category, OWASP, Resolver), sezione “Finding” (Id, Rule, Severity, Category, OWASP, Resolver, Description, Remediation) e sezione “HTTP summary” (metodo, status, URL con pulsante copia);
        
    - **Analyzer Findings**
        - naviga una lista di findings di Analyzer con colonne Finding ID, Rule e Document (tutti derivati dall’ID), più le Actions;
        - nel dettaglio, vede header con ruleId, severità, descrizione e metadati (Category, OWASP, Resolver), sezione “Finding” con i principali attributi, sezione “Context” (tipo contesto, origine, src copiabile) e sezione “HTML reference” con i frammenti HTML coinvolti (o messaggio di assenza nel caso non ve ne siano);
            
    - **Techstack Findings**
        - consulta la DataGrid Techstack con colonne Finding ID, Type, Scope, Subject (derivate dall’ID), più Actions;
        - nel drawer, vede header con regola, severità, eventuale evidenceType, descrizione e metadati; sezione “Finding” (Id, Rule, Severity, Category, Evidence type, Resolver, Description, Remediation);
        - esamina le sezioni di evidenza (Cookie / Header / Software evidence), comprendendo su quali cookie, header o software si basa il finding, e riceve messaggi espliciti quando una particolare evidenza è assente;
    
	  In tutti i dettagli Findings, l’utente può utilizzare azioni di copia su valori chiave (es. URL in HTTP Findings, src in Analyzer Findings) per riutilizzarli facilmente in report o strumenti esterni.

---

4. **Send PCAP**  
    Copre i casi d’uso della pagina **Send PCAP**, che realizza un flusso guidato (wizard) per caricare un file PCAP + chiavi TLS, estrarne le richieste HTTP e inviarne una selezione all’ontologia.
    
    I casi d’uso descrivono come l’utente:
    - segue uno **stepper verticale** a 6 passi (Upload PCAP, Upload SSL keys, Extract HTTP requests, Preview, Select, Confirm & Send), con titoli e descrizioni per ogni step e controlli contestuali (input file, griglie, checkbox);
    - carica il file PCAP (solo `.pcap` / `.pcapng`) e il file TLS key log (`.log` / `.txt`), con validazione dell’estensione, visualizzazione del nome file e gestione di eventuali errori tramite alert globale in cima alla pagina;
    - vede comparire, in presenza di errori (file mancanti, tipo non valido, nessuna request estratta, backend non raggiungibile), un **Alert** di errore con auto-scroll verso l’alto del wizard e possibilità di chiuderlo;
    - prima di ogni “Continue”, subisce un controllo dello stato del tool tramite health: se il tool è OFF l’avanzamento viene bloccato e compare un messaggio esplicito; se ON si procede con l’estrazione o con l’invio;
    - lancia l’estrazione delle HTTP requests da PCAP (step 2), osserva lo stato di caricamento (spinner, testo “Extracting…”, pulsanti disabilitati), riceve i risultati nella lista `requests` oppure un messaggio di assenza di richieste estratte;
    - visualizza in **Preview** una griglia read-only delle richieste estratte (metodo, status, URL, authority, body snippet), con possibilità di aprire un drawer di dettaglio (metadati request/response, headers, body con “Copy body”);
    - passa allo step di **selezione** delle richieste, dove può marcare più righe tramite checkbox, mantenendo un set di richieste selezionate e usando lo stesso drawer di dettaglio per l’ispezione;
    - si confronta con l’abilitazione contestuale del pulsante “Continue”/“Send requests”, che viene attivato o disattivato in base alla presenza dei file, all’esito dell’estrazione, alla quantità di richieste selezionate e allo stato delle operazioni asincrone (checking tool / loading extract / loading send);
    - nello step finale **Confirm and send** rivede l’elenco delle richieste selezionate, decide se attivare o meno il resolver tramite checkbox, e invia il tutto all’ontologia;
    - vede eventuali errori di validazione (nessuna richiesta selezionata, nessun batch valido) riportarlo a uno step precedente con messaggio chiaro;
    - segue la trasformazione delle richieste PCAP in payload “raw” compatibili con le API di ingestione (inclusi header e body base64), la creazione di uno o più batch e il loro invio, con gestione indipendente degli errori per batch;
    - riceve un **feedback finale** tramite snackbar con il rapporto X/Y job accettati e, in caso di successo parziale o totale, vede aprirsi il dialog **Job Summaries**, che mostra lo stato dei job (queue, jobId, ultimo evento, completed/failed) aggiornandosi via WebSocket e polling;
    - chiudendo il dialog Job Summaries, fa sì che il sistema pulisca le sottoscrizioni, fermi il polling, svuoti jobEvents e **resetti completamente il wizard** allo stato iniziale (step 0, file azzerati, richieste/selection cancellate, opzione resolver resettata).

---

5. **Tool Status**  
    Raccoglie i casi d’uso relativi alla pagina **Tool Status**, che fornisce una vista operativa sullo stato del backend e dei suoi componenti, oltre a un pannello di log in tempo reale.
    
    In questa sezione viene mostrato come l’utente:
    - accede alla pagina Tool Status dalla nav globale (`/server-status`) e trova tre aree principali: card riassuntiva dello stato tool, griglia di StatusCard per i componenti (API server, Redis, GraphDB, WebSocket), pannello “Real-Time Logs”;
    - beneficia di un polling periodico dell’endpoint di health (ogni ~5 secondi), sincronizzato con gli eventi della connessione WebSocket principale (riconfigurazione del timer all’on/off del WebSocket);
    - vede nella **card principale** lo stato consolidato del tool (`tool_on`, `checking`, `tool_off`) con un testo esplicito e una barra di progresso colorata, oltre all’orario dell’ultimo aggiornamento;
    - osserva la **griglia dei componenti** con quattro StatusCard che sintetizzano lo stato di API Server, Redis, GraphDB e WebSocket (connected/connecting/disconnected/up/down), ciascuna con un indicatore circolare colorato;
    - interpreta correttamente la normalizzazione degli stati: assenza di informazioni o valori non riconosciuti vengono mostrati come “down” o equivalenti, senza errori UI;
    - sfrutta la StatusCard WebSocket per capire se il canale real-time è operativo (connected) o meno (disconnected), indipendentemente dal resto delle funzionalità;
    - consulta il pannello **Real-Time Logs**, alimentato da un namespace WebSocket dedicato (`/logs`), che presenta una coda scorrevole di log con timestamp, livello, namespace e messaggio, codificando i livelli con colori differenti (info/success, warn, error);
    - continua a usare la pagina anche se non arrivano log o se la connessione `/logs` fallisce (il pannello resta semplicemente vuoto o fermo all’ultimo stato valido);
    - trova nella pagina Tool Status un riferimento principale per capire lo stato del backend in coerenza con l’indicatore globale di AppBar: problemi parziali o totali vengono riflessi negli stati dei componenti e nel valore consolidato `toolStatus`, senza mai provocare crash o schermate bianche.

---

6. **OpenAPI**  
    Copre i casi d’uso della sezione **OpenAPI / API Explorer**, dedicata all’esplorazione documentale delle API backend di OntoWeb-PT.
    
    I casi d’uso descrivono come l’utente:
    - accede alla route `/openapi` dalla voce “OpenAPI” e vede la pagina **API Explorer** con titolo, descrizione introduttiva (animata con Zoom), e – una volta caricato lo schema – l’elenco di gruppi di endpoint;
    - durante il caricamento del documento `openapi.json` vede una vista semplificata con solo uno spinner centrale, evitando di vedere gruppi incompleti o nulli;
    - esplora gli endpoint costruiti a partire da `schema.paths`, con una riga per ogni combinazione path+metodo HTTP realmente supportata (GET, POST, PUT, DELETE, PATCH, OPTIONS, HEAD), ignorando chiavi non operative;
    - osserva il **raggruppamento per tag**: gli endpoint vengono organizzati per tag OpenAPI (o “General” in mancanza del tag), ciascuno reso come sezione con titolo e lista di Accordion (uno per endpoint);
    - apre un Accordion e vede nell’header il chip del metodo HTTP (colorato per metodo), il path e il summary;
    - nel dettaglio, legge la descrizione dell’endpoint, quindi la sezione **Parameters**, dove i parametri sono raggruppati per location (query, path, header, cookie, altri) e mostrati con nome, obbligatorietà, tipo dedotto e descrizione;
    - beneficia di una tipizzazione dei parametri basata sugli schemi OpenAPI (param.schema o param.content["application/json"].schema), che usa una logica di inferenza semplice ma leggibile (string, number, array<…>, enum, object, any);
    - visualizza, dove previsto, la sezione **Request Body**, che mostra lo schema del payload (JSON o form) selezionato secondo un ordine di preferenza (application/json, multipart/form-data, application/x-www-form-urlencoded) e dereferenziato, reso come JSON formattato;
    - consulta la sezione **Responses Body**, che mostra un oggetto JSON aggregato per codice di stato, con descrizione e schema (solo per `application/json`), anch’essi dereferenziati;
    - sfrutta la logica di risoluzione dei `$ref` locali (`#/components/...`): gli schemi mostrati risultano in gran parte “espansi”, con gestione di cicli, merge con override locali e traversata di properties/items/allOf/anyOf/oneOf;
    - utilizza l’API Explorer in modalità **solo lettura**, senza la possibilità di invocare direttamente le API (niente “Try it out” né chiamate live), ma come documentazione interattiva degli endpoint disponibili per ingestione traffico HTTP, analisi, interrogazioni SPARQL e consultazione dei findings.

---