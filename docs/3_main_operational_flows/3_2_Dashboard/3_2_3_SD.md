# Sequence Diagrams
---

- [Global](./3_2_3_SD/3_2_3_1_Global.md)
- [Http Requests](./3_2_3_SD/3_2_3_2_Http_Requests.md)
- [Findings](./3_2_3_SD/3_2_3_3_Findings.md)
- [Send PCAP](./3_2_3_SD/3_2_3_4_Send_PCAP.md)
- [Tool Status](./3_2_3_SD/3_2_3_5_Tool_Status.md)
- [OpenAPI](./3_2_3_SD/3_2_3_6_OpenAPI.md)

---

Il documento “Sequence Diagrams” della sezione **Dashboard** raccoglie, in forma grafica (diagrammi di sequenza), i principali flussi dinamici dell’applicazione web OntoWeb-PT lato dashboard.  
Mentre i _Functional Requirements_ descrivono “che cosa” le singole pagine devono fare e i _Use Cases_ raccontano “come” l’utente interagisce con ciascuna funzionalità, i sequence diagrams mostrano “chi parla con chi e in quale ordine” (utente, router, componenti React, servizi REST, WebSocket, servizi di stato globale, ecc.) durante i diversi scenari operativi della dashboard.

---

Ogni gruppo di diagrammi è descritto in un file dedicato, allineato alle stesse aree funzionali già viste per FR e UC:

1. Global  
    La sezione **Global** dei sequence diagrams rappresenta i comportamenti trasversali comuni a tutta la dashboard. In particolare, i diagrammi mostrano:
    - la navigazione tra sezioni principali (Home, HTTP Requests, Findings, Send PCAP, Tool Status, OpenAPI) dalla barra laterale sinistra, con il router client-side che aggiorna solo l’area di contenuto mantenendo invariati header e nav;
    - la gestione degli URL diretti e dei tasti Indietro/Avanti del browser in un contesto SPA, con sincronizzazione tra route e stato della shell (LayoutShell + sezione attiva);
    - la sotto-navigazione contestuale per i Findings (HTTP / Analyzer / Techstack), che usa tab o pulsanti nell’AppBar per cambiare sotto-route e contenuto mantenendo lo stesso layout globale;
    - il cambio tema chiaro/scuro, con lettura iniziale dal `localStorage`, applicazione del tema all’intera UI, tentativo di persistenza e gestione di eventuali errori di storage in modo non bloccante;
    - il polling periodico dello stato del Tool (endpoint `/health`) e l’aggiornamento del chip globale in AppBar che riassume lo stato consolidato (`tool_on`, `checking`, `tool_off`);
    - il pattern di notifiche globali non bloccanti (snackbar) utilizzato dalle varie pagine per segnalare successi, warning ed errori;
    - il comportamento di degrado controllato in caso di problemi con lo storage locale o con il servizio di health, garantendo comunque il rendering del LayoutShell e la possibilità di navigare tra le pagine.
        
2. Http Requests  
    La sezione **Http Requests** dei sequence diagrams si concentra sulla lista delle richieste HTTP indicizzate nel backend e sulla loro consultazione dettagliata. I diagrammi illustrano:
    - il caricamento iniziale della pagina “HTTP Requests”: montaggio del componente, inizializzazione dello stato (paginazione, filtri) e uso della Backdrop bloccante solo per la primissima pagina, con DataGrid in modalità `loading` integrata per le richieste successive;
    - la paginazione server-side e il cambio page size, mantenendo i filtri correnti e ricalcolando `offset` / `limit` a ogni interazione;
    - l’applicazione dei filtri tramite pulsante **Apply** (solo quando i valori correnti differiscono dai filtri applicati) e l’operazione di **Reset** che azzera i filtri e ricarica la lista non filtrata dalla prima pagina;
    - la gestione dei casi “nessun risultato” (messaggio “No requests to show.”) e degli errori di listing (snackbar di errore, mantenimento dell’ultima lista valida, nessun crash);
    - l’apertura del dettaglio di una singola richiesta HTTP in un drawer laterale: click sulla riga, richiesta `getHttpRequestById`, spinner interno, rendering di URI, headers, body, metadati e azioni di copia; in caso di errore, chiusura automatica del drawer e snackbar non bloccante.
        
3. Findings  
    La sezione **Findings** dei sequence diagrams descrive i flussi dinamici relativi alla consultazione dei findings generati dal backend (HTTP, Analyzer, Techstack). I diagrammi coprono:
    - la sotto-navigazione interna tra **HTTP Findings**, **Analyzer Findings** e **Techstack Findings**, con router che cambia la pagina e sotto-nav che evidenzia la sezione attiva;
    - il primo caricamento della lista HTTP Findings su `/findings` (route di default), con Backdrop bloccante solo al primo accesso e DataGrid popolata con righe e totale;
    - il pattern uniforme di paginazione server-side per tutte le varianti di Findings, usando callback di `onPageChange` e `onPageSizeChange` per chiamare i servizi dedicati;
    - la gestione degli errori di caricamento: `loading` a `true` durante il fetch, snackbar in caso di failure, preservazione dell’ultimo dataset valido e interfaccia sempre utilizzabile;
    - l’apertura del dettaglio di un Finding (drawer laterale): scelta del servizio corretto in base al tipo (HTTP / Analyzer / Techstack), rendering di regola, severità, descrizione, metadati e sezioni specializzate, oltre a eventuali azioni di copia; gestione robusta degli errori con chiusura del drawer e notifica non bloccante.
        
4. Send PCAP  
    La sezione **Send PCAP** dei sequence diagrams rappresenta il wizard multi-step per inviare file PCAP e, opzionalmente, SSL keys al backend, estrarre richieste HTTP e inoltrarle all’ontologia. I diagrammi mostrano:
    - l’apertura della pagina “Send PCAP” e l’inizializzazione dello stato interno del wizard (step corrente, file caricati, richieste estratte, selezioni, flag di errore, ecc.), con visualizzazione dello stepper verticale;
    - il caricamento e la validazione dei file PCAP/SSL keys via file chooser, con controlli sulle estensioni ammesse, aggiornamento dello stato e gestione degli errori di validazione tramite alert globale e scroll automatico verso l’alto;
    - il controllo dello stato del tool (health-check) prima di consentire il passaggio di step con il pulsante “Continue”, mostrando stati intermedi (“Checking tool...”) e bloccando l’avanzamento se il tool è `tool_off`;
    - lo step di estrazione delle richieste HTTP dal PCAP: verifica della presenza dei file, chiamata al servizio di estrazione, aggiornamento della lista di richieste, passaggio allo step di anteprima e gestione dei casi particolari (nessuna richiesta estratta, errore backend);
    - la griglia di anteprima in sola lettura delle richieste estratte, con apertura del dettaglio in drawer e possibilità di copia dei body senza mutare la selezione;
    - lo step di selezione delle richieste da inviare all’ontologia: selezione multipla, comunicazione al componente padre del set selezionato, abilitazione/disabilitazione di “Continue” e possibilità di consultare i dettagli;
    - lo step finale di conferma e invio: normalizzazione delle richieste selezionate, suddivisione in batch, invio al backend, sottoscrizione dei job via WebSocket, snackbar di riepilogo, apertura del dialog “Job Summaries” e gestione di errori per singoli batch;
    - il monitoraggio dei job nel dialog “Job Summaries”, che riceve eventi via WebSocket, mantiene uno stato aggregato per jobId e, in parallelo, effettua un polling di fallback finché ci sono job non terminali;
    - la chiusura del dialog “Job Summaries” e il reset completo del wizard (inclusa la cancellazione delle sottoscrizioni e dell’history degli eventi), nonché il comportamento del pulsante “Back” e dell’alert globale di errore, che consente all’utente di tornare indietro di step senza lasciare residui di stato incoerente.
        
5. Tool Status  
    La sezione **Tool Status** dei sequence diagrams descrive i flussi dinamici relativi alla pagina di monitoraggio del backend OntoWeb-PT. I diagrammi mostrano:
    - l’apertura della pagina Tool Status e il primo recupero dello stato di health (`getHealth()`), con derivazione dello stato consolidato (`toolStatus`) tramite `deriveToolStatus` e aggiornamento della card principale e della griglia componenti, o degrado controllato a `tool_off` in caso di errore;
    - il polling periodico dell’endpoint di health (circa ogni 5 secondi), l’aggiornamento di `health`, `toolStatus` e “Ultimo aggiornamento” e la sincronizzazione con i cambiamenti di stato del WebSocket root (reset del timer e nuovo health-check immediato);
    - la gestione della connessione WebSocket principale (root): apertura all’inizializzazione, aggiornamento di `wsStatus` su `connect`/`disconnect`, riflesso nella StatusCard “WebSocket” e chiusura corretta in fase di unmount;
    - la sottoscrizione al namespace `/logs` per i log in tempo reale, con aggiornamento di un buffer circolare (ultimi ~80 eventi) e rendering del pannello “Real-Time Logs” in ordine di arrivo;
    - il rendering della card principale (stato tool, barra colorata, timestamp ultimo aggiornamento) e delle StatusCard per API server, Redis, GraphDB e WebSocket, inclusa la normalizzazione degli stati grezzi e la mappatura colore (verde/giallo/rosso);
    - il comportamento di degrado controllato in caso di problemi su health, WebSocket o log: card principale in `tool_off`, componenti `down`/`disconnected`, pannello log eventualmente vuoto, ma pagina sempre renderizzabile e navigabile.
        
6. OpenAPI  
    La sezione **OpenAPI** dei sequence diagrams copre i flussi dinamici della pagina **API Explorer**, dedicata alla consultazione documentale dello schema OpenAPI del backend. I diagrammi illustrano:
    - l’accesso alla pagina `/openapi`, il montaggio del componente, la visualizzazione dello stato di loading (spinner centrato) e il caricamento dinamico del file `openapi.json`; in caso di successo, costruzione dei gruppi di endpoint e visualizzazione di titolo, descrizione e lista per tag;
    - la costruzione dell’elenco di endpoint partendo da `schema.paths`, con filtraggio dei metodi validi, merge dei parametri path/operation (con precedenza a quelli di operazione) e determinazione del tag principale, producendo gruppi di Accordion per ciascuna categoria funzionale;
    - l’espansione di un Accordion di endpoint e la visualizzazione del pannello di dettaglio con sezione “Description” e sezione “Parameters”, quest’ultima organizzata per location (`query`, `path`, `header`, `cookie`, `other`) e arricchita con obbligatorietà, tipo e descrizione dei parametri;
    - la tipizzazione dei parametri tramite schemi dereferenziati: recupero dello schema, passaggio al motore di dereferenziazione `$ref`, applicazione delle regole di inferenza del tipo (array, type esplicito, enum, fallback object/any) e restituzione di una stringa sintetica;
    - la costruzione e visualizzazione della sezione “Request Body”, con scelta del content-type più rilevante (`application/json` → `multipart/form-data` → `application/x-www-form-urlencoded` → primo disponibile con schema), dereferenziazione e rendering JSON formattato;
    - la sezione “Responses Body”, che aggrega le risposte per codice di stato, estrae descrizione e schema JSON (`application/json`), dereferenzia gli schemi e li presenta in un oggetto JSON unico indicizzato per status code;
    - il comportamento di **sola lettura** dell’API Explorer, in cui l’unica operazione “live” è il caricamento di `openapi.json`, mentre tutte le altre interazioni (espansioni, consultazione di parametri e schemi) avvengono in memoria senza invocare realmente gli endpoint documentati, rendendo la sezione una pura documentazione interattiva delle API di OntoWeb-PT.

---