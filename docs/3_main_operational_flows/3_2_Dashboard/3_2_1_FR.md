# Requisiti Funzionali - Dashboard
---

- [Global](./3_2_1_FR/3_2_1_1_Global.md)
- [Http Requests](./3_2_1_FR/3_2_1_2_Http_Requests.md)
- [Findings](./3_2_1_FR/3_2_1_3_Findings.md)
- [Send PCAP](./3_2_1_FR/3_2_1_4_Send_PCAP.md)
- [Tool Status](./3_2_1_FR/3_2_1_5_Tool_Status.md)
- [OpenAPI](./3_2_1_FR/3_2_1_6_OpenAPI.md)

---

Il documento “Functional Requirements” della sezione **Dashboard** descrive, in modo strutturato, tutti i comportamenti attesi dall’interfaccia web di OntoWeb-PT (frontend React). È suddiviso in sei aree principali, ciascuna approfondita in un file dedicato:

---

1. **Global**  
    Raccoglie i requisiti funzionali trasversali a tutte le pagine della dashboard, indipendenti dalla singola vista (Requests, Findings, ecc.). In particolare definisce:
    - la **navigazione principale** tramite barra laterale sinistra, sempre presente, che consente l’accesso diretto alle sezioni: Home, HTTP Requests, Findings, Send PCAP, Tool Status, OpenAPI;
    - la **struttura di routing** e la coerenza delle URL (es. `/`, `/home`, `/http-requests`, `/findings/analyzer`, `/server-status`, `/send-pcap`, `/openapi`) mantenendo un layout comune (shell con AppBar + nav laterale);
    - la **sotto-navigazione contestuale** per la sezione Findings (tab HTTP / Analyzer / Techstack) visibile solo sulle route `/findings/...`;
    - la **gestione globale del tema** chiaro/scuro (dark/light), con persistenza in localStorage e adattamento di elementi grafici (logo, colori principali);
    - l’**indicatore globale di stato del Tool** (chip “Tool On / Tool Off / Tool Checking”) basato sul servizio di health polling periodico;
    - la **Home/Dashboard** come pagina di onboarding, con descrizione del flusso OntoWeb-PT e feature card cliccabili verso le sezioni principali;
    - il **layout responsivo** tra desktop e schermi ridotti (riduzione nav laterale a icone, nessuno scroll orizzontale necessario);
    - il **sistema di notifiche globali** non bloccanti (snackbar/toast) per conferme, errori recuperabili, messaggi informativi;
    - il **degrado controllato** in caso di problemi con lo storage locale o con i servizi globali (tema di default, stato Tool “Off” ma UI comunque utilizzabile).

---

2. **Http Requests**  
    Specifica i requisiti per la sezione che visualizza le richieste HTTP normalizzate in ontologia (GraphDB). In particolare descrive:
    - la **vista tabellare paginata server-side** delle richieste HTTP, con parametri `offset`/`limit` e scelta del page size (25/50/100);
    - lo **schema delle colonne** della griglia (Method, Status, URL canonica, Authority, Graph) e il messaggio di assenza dati (“No requests to show.”);
    - la **distinzione tra primo caricamento e reload**: Backdrop bloccante con spinner all’initial load, solo spinner integrato per i refresh successivi;
    - la **toolbar dei filtri** (Method, Scheme, Authority, Path, Full-text) con normalizzazione degli input e invio al backend solo dei campi non vuoti;
    - il comportamento controllato dei filtri (Apply/Reset), con detection delle modifiche rispetto ai filtri applicati e reset della paginazione alla prima pagina;
    - la **gestione errori** nel caricamento lista (snackbar “Error while executing the request.”, mantenimento dell’ultimo set valido);
    - l’**apertura del dettaglio richiesta** in drawer laterale tramite azione “View details” (e non tramite click di riga);
    - il contenuto del **dettaglio**: header con chip Method/Status colorato, URL con “Copy URL”, metadati Graph/Connection; sezione Request (URI, query params, headers) e sezione Response (status, headers, body con “Copy body” e gestione assenza body);
    - la **codifica visiva dello status HTTP** (2xx success, 3xx info, 4xx warning, 5xx error) tramite chip colorati coerenti;
    - l’**interazione fra filtri e paginazione** (filtri resettano l’offset, paginazione mantiene i filtri, allineamento costante tra stato UI e parametri usati nelle chiamate al backend).

---

3. **Findings**  
    Descrive i requisiti per l’intera sezione Findings e per le sue tre sottosezioni:
    - **HTTP Findings**
    - **Analyzer Findings**
    - **Techstack Findings**
    
    In particolare:
    - la **sotto-navigazione interna** (Http / Analyzer / Techstack) visualizzata solo su route `/findings`, con pulsante della vista corrente disabilitato/evidenziato;
    - la **pagina di default** `/findings` che corrisponde a HTTP Findings;
    - il **layout comune** delle tre pagine: titolo, blocco descrittivo introduttivo con animazione `Zoom`, griglia o messaggio “No findings to show.”;
    - la **paginazione server-side uniforme** basata su `offset/limit/total` per tutte le liste, con DataGrid in `paginationMode="server"` e page size 25/50/100;
    - la gestione dello **stato di caricamento iniziale** (Backdrop bloccante se loading e nessuna riga) e dei caricamenti successivi (spinner interno alla DataGrid);
    - la **gestione errori** di listing con snackbar dedicati (“Error while loading HTTP/Analyzer/Techstack findings.”) e UI che resta utilizzabile;
    - l’**apertura del dettaglio finding** in drawer laterale tramite icona “View details”, con recupero puntuale dei dati (`getHttpFindingById`, `getAnalyzerFindingById`, `getTechstackFindingById`) e wrapper DrawerWrapper condiviso;
    - il comportamento in caso di errore nel dettaglio (snackbar “Error while retrieving finding details.”, reset oggetto e chiusura drawer);
    - la **codifica colore della severità** via Chip (`LOW`→info, `MEDIUM`→warning, `HIGH/CRITICAL`→error, else default), visibile nell’header e nella sezione Finding.
    
    Per ciascuna sottosezione vengono inoltre definiti requisiti specifici:
    
    - **HTTP Findings**:
        - caricamento elenco tramite `listHttpFindings({ offset, limit })` e adattamento degli ID a righe `{ id }`;
        - DataGrid con colonne sintetiche: Finding ID (con tooltip), Rule (estratta dall’ID con parsing del formato `ns:resolver:http:rule:target...`), Target (segmenti successivi alla rule), Actions;
        - dettaglio con header (chip ruleId, severità, descrizione, meta Category/OWASP/Resolver) e sezione “Finding” (Id, Rule, Severity, Category, OWASP category, Resolver, Description, Remediation) + sezione “HTTP summary” (Method, Status, URL con “Copy URL”).
    - **Analyzer Findings**:
        - caricamento tramite `listAnalyzerFindings({ offset, limit })` e mapping `{ id }`;
        - DataGrid con colonne: Finding ID, Rule (terzo segmento dell’ID decodificato), Document (quarto segmento), Actions;
        - dettaglio con header (ruleId, severità, descrizione, Category/OWASP/Resolver), sezione “Finding” (Id, Rule, Severity, Category, OWASP category, Resolver, Description), sezione “Context” (Type, Origin, src con tooltip + “Copy source URL”) e sezione “HTML reference” (lista nodi HTML con iri + source o messaggio “No HTML reference available.”).
    - **Techstack Findings**:
        - caricamento tramite `listTechstackFindings({ offset, limit })` e righe `{ id }`;
        - DataGrid con colonne: Finding ID, Type (3° segmento), Scope (4°), Subject (5°), Actions;
        - dettaglio con header (ruleId o rule derivata, severità, chip evidenceType, descrizione, Category/Resolver), sezione “Finding” (Id, Rule, Severity, Category, Evidence type, Resolver, Description, Remediation), e sezioni di evidenza:
            - **Cookie evidence** (IRI, Name, Domain, Secure, HttpOnly o messaggio “No cookie evidence available.”);
            - **Header evidence** (lista `name: value` o messaggio “No header evidence available.”);
            - **Software evidence** (Name, Version, Category, Vendor o messaggio “No software evidence available.”).
    
    Vengono infine definiti i punti in cui il dettaglio prevede azioni di copia negli appunti (URL HTTP summary, src in Analyzer).
    

---

4. **Send PCAP**  
    Definisce il flusso guidato (wizard) per caricare un file di cattura (PCAP/PCAPNG) e un file di TLS key log, estrarre le richieste HTTP, selezionarle e inviarle all’ontologia. In particolare copre:
    - lo **stepper verticale** in 6 passi:
        1. Upload PCAP file
        2. Upload SSL keys file
        3. Extract HTTP requests
        4. Preview extracted requests
        5. Select requests for ontology
        6. Confirm and send
    - la **validazione delle estensioni** per i due file (PCAP/PCAPNG per la cattura, LOG/TXT per le chiavi), con scarto dei file non validi e messaggi di errore globali;
    - l’**alert globale di errore** (MUI Alert) e l’auto-scroll verso l’alto quando `errorMessage` è valorizzato;
    - il **controllo dello stato del tool** prima di ogni “Continue” (health check + deriveToolStatus, blocco avanzamento se Tool Off o irraggiungibile, messaggi tipo “The analysis tool is currently OFF…”);
    - la logica di **estrazione delle richieste HTTP da PCAP** allo step 2 (verifica presenza file, chiamata `pcapService.extractHttpRequestsFromPcap`, gestione `loadingExtract`, popolamento `requests`, salto diretto allo step 3, messaggi in caso di 0 risultati o errori backend);
    - gli **stati di caricamento** durante l’estrazione (spinner + testo dedicato, pulsanti Continue/Back disabilitati in corso di elaborazione);
    - la **preview read-only** delle richieste estratte (step 3) tramite `PcapRequestsDataGrid` con coscienza di Method/Status/URL/Authority/Body snippet e drawer di dettaglio (request/response, headers, body, “Copy body”, gestione assenza body);
    - la **selezione delle richieste** (step 4) tramite `PcapRequestsDataGridSelectable`, con modello di selezione custom include/exclude, propagazione di `selectedRequests` al parent e stessi dettagli drawer della griglia read-only;
    - le **regole di abilitazione** del pulsante “Continue”/“Send requests” per ciascuno step, considerando presenza file, numero di requests/selectedRequests, stati `loadingExtract`, `loadingSend`, `checkingTool`;
    - l’opzione di **attivazione del resolver** (checkbox “Enable resolver to detect potential vulnerabilities.” allo step 5) e la preview finale delle richieste selezionate;
    - la **normalizzazione delle richieste** in formato raw per l’ingestione (`mapPcapItemsToRawItems`: id, request/response headers, body base64, meta.pageUrl, gestione header invalidi);
    - la **creazione dei batch** con `makeBatchPayloads` (limite dimensione payload, safety margin, grafo di destinazione da env o default);
    - l’**invio all’ontologia** con `httpRequestsService.ingestHttpRequests({ ...batch, activateResolver })`, gestione errori per singolo batch via snackbar e sottoscrizione ai jobId (requests/resolver) tramite websocket (`subscribeJob`);
    - il **feedback finale** (conteggio job accettati, snackbar “Requests accepted by the backend: X/Y…”, apertura dialog “Job Summaries”);
    - la **raccolta degli eventi job** via WebSocket (`socketService.onJobEvent`) e la costruzione dei riepiloghi aggregati (jobId, queue, lastEvent, completed/failed, raw);
    - il **polling di fallback** degli stati dei job mentre il dialog è aperto, tramite `httpRequestsService.getHttpIngestResult(id)` e generazione di eventi sintetici (completed/failed/update) fino all’esaurimento dei job sottoscritti;
    - la logica del **dialog “Job Summaries”** (lista job con icona colorata in base a completed/failed/pending, spinner se ancora nessun riepilogo);
    - la **chiusura del dialog** con reset completo del wizard (step, file, richieste, selezioni, flag resolver, errori, stati di caricamento) e tentativi di `socketService.unsubscribeJob` su ogni job residuo;
    - la gestione coerente del pulsante **“Back”** (no passo sotto 0, blocco durante operazioni critiche) e degli eventuali **errori imprevisti** con messaggi di fallback e reset degli stati `loading*` nei `finally`.

---

5. **Tool Status**  
    Copre i requisiti della pagina di monitoraggio stato del backend (“Tool Status”), che fornisce una vista operativa centrale del sistema OntoWeb-PT. In particolare:
    - il **polling periodico** del servizio REST `/health` tramite `getHealth` e la derivazione dello stato aggregato del tool (`deriveToolStatus` → `tool_on`, `checking`, `tool_off`);
    - la visualizzazione di un **main status card** con:
        - titolo “Tool Status: …” e timestamp di ultimo aggiornamento;
        - progress bar (`LinearProgress`) colorata in base allo stato (success, warning, error);
    - la griglia di **StatusCard** per sottosistemi:
        - API Server (health component server);
        - Redis;
        - GraphDB;
        - WebSocket (stato di connessione client);
    - la gestione della **connessione WebSocket** root (namespace principale) per tenere traccia di `wsStatus` (connected/disconnected) e per triggerare repoll del health;
    - la sottoscrizione al namespace `/logs` della WebSocket per ricevere un flusso di log strutturati (ts, level, ns, msg) e mantenerne solo la coda recente (buffer compatto ~80 eventi);
    - la renderizzazione della sezione **Real-Time Logs**:
        - card dedicata con titolo “Real-Time Logs”;
        - elenco a scorrimento dei log con timestamp, livello a colore differenziato (error/warn/altro), namespace e messaggio (stringa o JSON stringificato);
    - la gestione sicura degli errori di health check o websocket (default conservativo `tool_off`, nessun crash UI).

---

6. **OpenAPI**  
    Descrive i requisiti per la pagina **API Explorer**, che permette di esplorare lo schema OpenAPI del backend direttamente dalla dashboard. In particolare:
    - il **caricamento lazy** del documento OpenAPI (JSON locale) con stato di loading iniziale (spinner centrato finché `schema` è null);
    - la costruzione di **gruppi di endpoint per tag** a partire da `schema.paths`, considerando solo metodi HTTP supportati (`GET, POST, PUT, DELETE, PATCH, OPTIONS, HEAD`);
    - la **fusione dei parametri** dichiarati a livello path e a livello operation, con precedenza a quelli dell’operation (`mergeParameters`) e de-duplicazione basata su chiave composta (`in:name`);
    - la pagina con titolo “API Explorer” e **blocco descrittivo introduttivo** (Paper con animazione `Zoom`) che spiega cosa è possibile esplorare (ingest, analisi HTTP, estrazione da PCAP, SPARQL, findings, ecc.);
    - la renderizzazione di un **OpenAPIGroup** per ciascun tag:
        - header con metodo (Chip colorato in base al verbo), path e summary;
        - corpo espandibile (Accordion) con descrizione, parametri raggruppati per `in` (query, path, header, cookie) e tipologia dedotta;
        - sezione **Request Body** che mostra lo schema dereferenziato del body preferendo i content type `application/json`, `multipart/form-data`, `application/x-www-form-urlencoded` (o il primo schema disponibile);
        - sezione **Responses Body** che mostra, per ciascuno status HTTP, descrizione e schema JSON dereferenziato;
    - la gestione della **risoluzione dei riferimenti** `$ref` locali (`#/components/...`) con detection di cicli e dereferenziazione ricorsiva di properties, items, combinatori (allOf, anyOf, oneOf);
    - la presentazione degli schemi in forma di blocchi `pre` JSON indentati, a sola lettura, per facilitare consultazione e sviluppo di client/tool esterni.

---